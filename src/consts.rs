use dashu::integer::UBig;

/// # MODULUS
/// This is the The modulus Fq2
/// 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47
///
/// We use this value to
pub static MODULUS: UBig = unsafe {
    UBig::from_static_words(&[
        0x3c208c16d87cfd47,
        0x97816a916871ca8d,
        0xb85045b68181585d,
        0x30644e72e131a029,
    ])
};

/// The last multiple of the modulus before 2^256 used to normalize
/// hash values for our signing scheme.
///
/// 0xf1f5883e65f820d099915c908786b9d3f58714d70a38f4c22ca2bc723a70f263
pub static NORMALIZE_MODULUS: UBig = unsafe {
    UBig::from_static_words(&[
        0x2ca2bc723a70f263,
        0xf58714d70a38f4c2,
        0x99915c908786b9d3,
        0xf1f5883e65f820d0,
    ])
};

pub const G1_MINUS_ONE: [u8; 64] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01,
    0xb0, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81,
    0x58, 0x5d, 0x97, 0x81, 0x6a, 0x91, 0x68, 0x71, 0xca, 0x8d, 0x3c, 0x20, 0x8c, 0x16,
    0xd8, 0x7c, 0xfd, 0x45,
];

pub const G2_MINUS_ONE: [u8; 128] = [
    0x19, 0x8e, 0x93, 0x93, 0x92, 0x0d, 0x48, 0x3a, 0x72, 0x60, 0xbf, 0xb7, 0x31, 0xfb, 0x5d, 0x25,
    0xf1, 0xaa, 0x49, 0x33, 0x35, 0xa9, 0xe7, 0x12, 0x97, 0xe4, 0x85, 0xb7, 0xae, 0xf3, 0x12, 0xc2,
    0x18, 0x00, 0xde, 0xef, 0x12, 0x1f, 0x1e, 0x76, 0x42, 0x6a, 0x00, 0x66, 0x5e, 0x5c, 0x44, 0x79,
    0x67, 0x43, 0x22, 0xd4, 0xf7, 0x5e, 0xda, 0xdd, 0x46, 0xde, 0xbd, 0x5c, 0xd9, 0x92, 0xf6, 0xed,

    //0x27,
    0xa7, 0x5d, 0xc4, 0xa2, 0x88, 0xd1, 0xaf, 0xb3, 0xcb, 0xb1, 0xac, 0x09, 0x18, 0x75, 0x24, 0xc7,
    0xdb, 0x36, 0x39, 0x5d, 0xf7, 0xbe, 0x3b, 0x99, 0xe6, 0x73, 0xb1, 0x3a, 0x07, 0x5a, 0x65, 0xec,
    0x1d, 0x9b, 0xef, 0xcd, 0x05, 0xa5, 0x32, 0x3e, 0x6d, 0xa4, 0xd4, 0x35, 0xf3, 0xb6, 0x17, 0xcd,
    0xb3, 0xaf, 0x83, 0x28, 0x5c, 0x2d, 0xf7, 0x11, 0xef, 0x39, 0xc0, 0x15, 0x71, 0x82, 0x7f, 0x9d,
];

#[cfg(all(test, not(target_os = "solana")))]
mod tests {
    use super::G1_MINUS_ONE;
    use ark_bn254::G1Affine;
    use ark_serialize::CanonicalSerialize;
    use ark_ec::AffineRepr;

    #[test]
    fn test_g1_minus_one() {
        // Compute negation of G1 generator
        let g1_gen = G1Affine::generator();
        let g1_neg = -g1_gen;
        let mut computed_bytes = [0u8; 64];
        g1_neg
            .serialize_uncompressed(&mut computed_bytes[..])
            .expect("Serialization failed");

        // Convert to big-endian by reversing each 32-byte block (x and y coordinates)
        computed_bytes[0..32].reverse();
        computed_bytes[32..64].reverse();

        // Verify against static constant
        assert_eq!(
            computed_bytes, G1_MINUS_ONE,
            "Computed G1_MINUS_ONE does not match static constant"
        );
    }

    #[test]
    fn test_g2_minus_one() {
        use super::G2_MINUS_ONE;
        use ark_bn254::G2Affine;
        use ark_serialize::CanonicalSerialize;
        use ark_ec::AffineRepr;

        // Compute negation of G2 generator
        let g2_gen = G2Affine::generator();
        let g2_neg = -g2_gen;
        let mut computed_bytes = [0u8; 128];
        g2_neg
            .serialize_uncompressed(&mut computed_bytes[..])
            .expect("Serialization failed");

        // Convert to big-endian by reversing each 64-byte block (x and y coordinates)
        computed_bytes[0..64].reverse();
        computed_bytes[64..128].reverse();

        // Verify against static constant
        assert_eq!(
            computed_bytes, G2_MINUS_ONE,
            "Computed G2_MINUS_ONE does not match static constant"
        );
    }
}
